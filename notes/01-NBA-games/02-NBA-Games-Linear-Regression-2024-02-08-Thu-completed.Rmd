---
title: "Predicting NBA Game Outcomes"
author: "S&DS 361"
date: "2024-02-06"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(pubtheme)
library(gganimate)

```


## Review Simple Linear Regression
The simple linear regression model can be written 

$$ Y = \beta_0 + \beta_1 x + \epsilon, \quad \epsilon \sim N(0, \sigma^2) $$

We can think of this as a deterministic relationship that is linear ($\beta_0 + \beta_1 x$), plus some non-deterministic/randomness component $\epsilon$. 

We use a capital $Y$ for the outcome to indicate that $Y$ is a random variable, which it is since it equals a constant plus a random variable ($\epsilon$). 

To understand this further, let's use $x^*$ to denote a particular value of $x$. For a given $x^*$, we have

1. $E(Y|x^*) = E(\beta_0 + \beta_1 x^* + \epsilon) = \beta_0 + \beta_1 x^* + E(\epsilon) = \beta_0 + \beta_1 x^*$
2. $V(Y|x^*) = V(\beta_0 + \beta_1 x^* + \epsilon) = V(\epsilon) = \sigma^2$
3. $Y$ is normally distributed (since it is constant + $\epsilon$ and $\epsilon$ is normal)

So for any given $x^*$, we have that $Y \sim N(\beta_0 + \beta_1 x^*, \sigma^2)$. 


## Review linear regression assumptions

- Linearity: The relationship between the predictors and the outcome is linear.
- Independence: The error are independent.
- Normality: The outcome is normally distributed at each x.
- Constant variance: The variance of the outcome is equal for all x.



## NBA games data
```{r}
d = readRDS('data/games.rds')

## Basketball
nba = d %>% 
  filter(lg == 'nba', 
         season %in% 1990:2023, 
         season.type == 'reg') %>%
  select(date, away, home, 
         ascore, hscore, season, gid)
head(d)

da = nba %>% select(date, away, ascore, home, hscore, season, gid) %>% mutate(ha = 'away')
dh = nba %>% select(date, home, hscore, away, ascore, season, gid) %>% mutate(ha = 'home')
colnames(da) = c('date', 'team', 'score',  'opp', 'opp.score', 'season', 'gid', 'ha')
colnames(dh) = c('date', 'team', 'score',  'opp', 'opp.score', 'season', 'gid', 'ha')
db = bind_rows(da, dh) %>% 
  arrange(date, gid)
head(db)
```
First let's create a column that represents how good the team was in the previous season. We'll start by finding the average score and score allowed for each team in each season. 


```{r}
ds = db %>%
  group_by(team, season) %>%
  summarise(avg.score = mean(score), 
            avg.opp.score = mean(opp.score))
         
head(ds,2)
```

```{r}
db = db %>%
  mutate(prev.season = as.character(as.numeric(season) - 1)) 
head(db,2)
```

We want to add columns for the previous season's average score for the `team` in each row. We can do this by adding a `prev.season` column to `db` and joining `ds` with `db`.  

```{r}
dd = db %>%
  left_join(ds, 
            by = c('team', 
                   'prev.season' = 'season')) %>%
  filter(!is.na(avg.score), 
         score != 0) %>%
  rename(avg.score.prev = avg.score)
head(dd)
```

If we'd like, we can also make adjustments for the opponent and the season. If, for example, the opponent allowed 1 more point than league average, we'll adjust average score up by 1.

```{r}
dl = db %>%
  group_by(season) %>%
  summarise(lg.avg.score = mean(score)) 
head(dl,2)
```

```{r}
ds = ds %>%
  
  left_join(dl, 
            by = 'season') %>%
  
  mutate(score.above.lg.avg     = avg.score     - lg.avg.score,
         opp.score.above.lg.avg = avg.opp.score - lg.avg.score)
  
```

```{r}
dd = dd %>%
  left_join(ds %>% select(team, 
                          season, 
                          opp.score.above.lg.avg), 
            by = c('opp' = 'team', 
                   'prev.season' = 'season')) %>%
  left_join(dl, 
            by = 'season') %>%
  left_join(dl, 
            by = c('prev.season' = 'season'), 
            suffix = c('', '.prev')) %>%
  rename(opp.score.above.lg.avg.prev = opp.score.above.lg.avg) %>%
  mutate(avg.score.prev.adj = 
           avg.score.prev +
           opp.score.above.lg.avg.prev +
           lg.avg.score - lg.avg.score.prev) %>%
  
  select(date, team, score, 
         opp, opp.score, season,
         ha, gid, 
         avg.score.prev, avg.score.prev.adj)
head(dd,2)
```


Let's see if there is a relationship between the previous season's average score (adjusted) and the `score` for the `team` in each game. 

```{r fig.width = 5, fig.height = 5}
g = ggplot(dd,
           aes(x = avg.score.prev, 
               y = score)) +
  geom_point(color = pubdarkgray,
             alpha = 0.05)
g %>% 
  pub(type = 'scatter')

```

Note that `score` appears fairly normally distributed.

```{r}
title = 'Distribution of Team Points in NBA Games'
g  = ggplot(dd, aes(x = score))+
  geom_histogram(fill = pubred, 
                 color = pubbackgray, 
                 binwidth = 5) +
  labs(title    = title,
       x = 'Team Points Scored in a Game', 
       y = 'Count')

g %>% 
  pub(type = 'hist')

```


```{r fig.width=6, fig.height=6}
g  = ggplot(dd, 
            aes(sample = score))+
  geom_qq() +
  geom_qq_line()

g %>% 
  pub(type = 'scatter')
```

The tails don't look perfect, but this will be better later when we include more information than simply average points from the previous season.  

Also, what we actually need is not that `score` is normally distributed, but that `score` is normally distributed *for a given set of predictors*, or in this case, for a given value of `avg.score.prev`. Note that if we look at a single value of `avg.score.prev`, there may be few or no observations that have that exact value of `avg.score.prev`, so we will look at small ranges of `avg.score.prev`.

If we look at the distribution of `score` for different subsets of our predictor `avg.score.prev`, it should look roughly normal for each subset. We can eyeball this by looking at the scatter plot. But let's actually plot it, in part to practice data summarization and visualization, and in part because we'll want to create similar visualizations later in other situations in which it might be less easy to eyeball.  

We can bin our data using the function `cut_interval`.

```{r}
dd = dd %>%
  mutate(bin = cut_interval(avg.score.prev, 
                            length = 5))
head(dd)
```

Let's plot the distribution of score separately for every bin. 

```{r}
g = ggplot(dd, 
           aes(x = score))+
  geom_histogram(binwidth = 5)+
  facet_wrap(~bin, 
             scales = 'free_y', 
             dir = 'v')

g %>% 
  pub(type = 'hist', 
      facet = T, 
      base_size = 9)
```

Hmm, it would be nice to have a vertical line showing the mean for every bin. 

```{r}
bin.means = dd %>%
  group_by(bin) %>%
  summarise(mean.score = mean(score), 
            var.score = var(score), 
            n = n())
bin.means
```

We see that the means increase with the bins (except for bins with small sample size issue). We also, unfortunately, see that the variances seem to increase as well. Note that if we think our outcome is roughly normal for every $x$, and we expect the variance to be roughly equal for all subsets. The constant variance assumption in linear regression is violated somewhat, but let's go with it for now. This will get better when we consider more information that simply `avg.score.prev`. 

Let's plot our histograms with the vertical lines.

```{r fig.height=5, fig.width=5}
g = ggplot(data = dd, 
       aes(x = score))+
  geom_histogram(binwidth = 5) + 
  geom_vline(data = bin.means, 
             aes(xintercept = mean.score), 
             color = pubred)+
  facet_wrap(~bin,
             ncol = 2, 
             scales = 'free_y', 
             dir = 'v')

g %>% 
  pub(type = 'hist',
      facet = T, 
      base_size = 9)
```

So `score` appears to be approximately normal for each subset of the predictors, except for those with small sample size. 

What about the linearity assumption? Let's recreate our previous scatter plot, let's add the mean of `score` for each bin at the midpoint of each bin. First, let's find the midpoint of each bin. In this case, the bins are 5 units wide, with integer endpoints, so the midpoints easy to determine as 72.5, 77.5, 82.5, etc.

```{r}
bin.means = bin.means %>%
  mutate(mid = seq(from = 82.5, 
                   to   = 122.5, 
                   by   = 5))
bin.means
```

Note if it weren't so easy to determine the midpoints, we can use regular expressions to extract the endpoints from the `bin` column.

```{r}
bin.means = bin.means %>%
  separate(bin, 
           into = c('left', 'right'), 
           sep = ',', 
           remove = F) %>%
  mutate(left = gsub('[', '', left, fixed = T), 
         left = gsub('(', '', left, fixed = T),
         right = gsub(']', '', right, fixed = T), 
         mid2 = (as.numeric(left) + as.numeric(right))/2)
bin.means


```

We could have also put `[`, `]`, and `(` in square brackets and it would look for those specific characters
```
mutate(right = gsub('[]]', '', right )  ## find ] and remove it
       left  = gsub('[([]', '', left ), ## find ( or [ and remove them 
       mid2 = (as.numeric(left) + as.numeric(right))/2)

```

Now let's plot the `mean.score` of each bin on the scatter plot, at the midpoint `mid` of each bin. 

```{r fig.width = 6, fig.height = 6}
g = ggplot(dd,
           aes(x = avg.score.prev, 
               y = score)) +
  geom_point(color = pubdarkgray,
             alpha = 0.05) + 
  geom_point(data = bin.means, 
             aes(x = mid, 
                 y = mean.score, 
                 size = n), 
             color = pubred) + 
  geom_line(data = bin.means, 
            aes(x = mid, 
                y = mean.score), 
            color = pubred)

g %>%
  pub(type = 'scatter')
```

The relationship looks pretty linear, at least for the bins with larger sample sizes (larger dots).

Here's an animation showing the distribution of score for a moving window of `avg.score.prev`. 

```{r eval=F}
n.frames = length(seq(80, 116, by=4))

## lines
dl = data.frame(left  = seq(80  , 116  , length=n.frames), 
                right = seq(80+5, 116+5, length=n.frames), 
                frame = 1:n.frames) %>%
  mutate(mid = left/2 + right/2)

## Stack two data frames that we want to use
## to plot in two windows 
## Give each one NAs so it doesn't show up in the other window
## This is super hack-y, but it avoids making separate animations and 
## using magick to glue them together

dl1 = dl %>% mutate(window='Subsets of predictor', 
                    end=121)
dl2 = dl %>% 
  mutate(window='Distribution of score for the subset', 
         left=NA, 
         right=NA, 
         mid=NA, 
         end=NA)

dl = rbind(dl1, dl2) %>%
  mutate(window = relevel(factor(window), 
                          'Subsets of predictor'))


## Gotta manually jitter, 
## otherwise the jitter will be different in each frame
## Not necessary for linear regression but we'll keep it anyway

dd = dd %>%
  mutate(jitter.score = jitter(score, amount=0.25))

## data for histogram and highlighted points
ddh = NULL
for(j in  dl$frame){
  cat(j, '')
  left  = dl$left[j]
  right = dl$right[j]
  temp  = dd %>% 
    mutate(inside = ifelse(avg.score.prev <= right & 
                           avg.score.prev >= left, 
                           TRUE, FALSE), 
           frame = j)
  
  ddh = rbind(ddh, temp)
}

## mean of highlighted points
dm = ddh %>% 
  filter(inside==TRUE) %>%
  group_by(frame) %>%
  summarise(mean = mean(score), 
            var = var(score), 
            n = n()) %>% 
  as.data.frame()


dl = dl %>% left_join(dm, by='frame')
dl = dl %>% 
  mutate(mean.hist = ifelse(window=='Subsets of predictor', NA  , mean), 
         mean      = ifelse(window=='Subsets of predictor', mean, NA  ))

ddh2 = ddh %>% 
  mutate(hist.score = ifelse(inside==TRUE, score, NA),
         avg.score.prev = NA,
         window = 'Distribution of score for the subset') 

ddh$hist.score = NA
ddh$window = 'Subsets of predictor'
ddh = rbind(ddh, ddh2)
ddh = ddh %>% 
  mutate(window = relevel(factor(window), 
                          'Subsets of predictor'))
#ddh = ddh %>% filter(frame %in% c(1,23))

## sample of data
samp = sample(unique(ddh$avg.score.prev), 100)
title = 'Distribution of Team Goals for Different Subsets'
g = ggplot(ddh %>% 
             filter(frame %in% c(1:n.frames), 
                    (avg.score.prev %in% samp |
                     is.na(avg.score.prev))), 
       aes(x=avg.score.prev, 
           y=jitter.score, 
           color=inside, 
           group=gid))+
  geom_point(alpha=0.3,
             show.legend = F)+
  scale_color_manual(values = c(publightgray,
                                pubred))+
  geom_vline(data=dl %>%
               filter(frame %in% c(1:n.frames)),
             aes(xintercept=left), 
             color=pubdarkgray)+
  geom_vline(data=dl %>%
               filter(frame %in% c(1:n.frames)),
             aes(xintercept=right), 
             color=pubdarkgray)+
  geom_point(data = dl %>%
               filter(window=='Subsets of predictor'),
             aes(x=mid, 
                 y=mean),
             color=pubdarkgray,
             size=2,
            inherit.aes = F)+
  geom_segment(data = dl,
               aes(x=mid , xend=end,
                   y=mean, yend=mean),
               color = pubdarkgray,
               inherit.aes = F, 
               linewidth=1)+
  geom_histogram(aes(x = after_stat(density),
                     y = hist.score),
                 fill=pubred,
                 color=pubbackgray,
                 binwidth=5,
                 inherit.aes = FALSE)+
  geom_hline(data=dl, 
             aes(yintercept=mean.hist), 
             color=pubdarkgray, 
             linewidth=1)+
  facet_wrap(~window, scales='free_x')+
  scale_x_continuous(oob = squish, 
                     expand = c(0,0))+
  scale_y_continuous(limits = c(40,180), 
                     breaks = c(40, 110, 180),
                     oob = squish, 
                     expand = c(0,0))+
  labs(title    = title,
       x = 'Predictor                                                         Proportion', 
       y = 'Score')+  
  theme_pub(type='hist', base_size=36/3, facet=T) 

gg = g + 
  transition_states(frame, 
                    transition_length = 1, 
                    state_length = 0,
                    wrap=F)

a = animate(gg,
            fps=10,
            nframes = 2*n.frames + 10,
            height=320,
            width=480,
            end_pause=10)
a

anim_save(a, filename = 'img/dist.of.score.for.different.subsets.nba.gif')

```

![](img/dist.of.score.for.different.subsets.nba.gif)


## A simple linear regression for NBA game outcomes

```{r}
lm1 = lm(score ~ avg.score.prev, data=dd)
summary(lm1)
```


## Prediction

```{r}
dd$yhat = predict(lm1, newdata = dd)
head(dd %>% select(score, opp.score, avg.score.prev, yhat))
```

```{r}
temp = data.frame(avg.score.prev = 100)
predict(lm1, newdata = temp)
predict(lm1, newdata = temp, interval = 'confidence', level = 0.95)
predict(lm1, newdata = temp, interval = 'prediction', level = 0.95)

```

                                                                              
## Confidence interval

```{r}
dd$yhat.lower = predict(lm1, 
                        newdata = dd, 
                        interval = 'confidence',
                        level = 0.95)[,'lwr']

dd$yhat.upper = predict(lm1, 
                        newdata = dd, 
                        interval = 'confidence',
                        level = 0.95)[,'upr']

dd %>% 
  select(score, opp.score, avg.score.prev, 
         yhat, yhat.lower, yhat.upper) %>%
  head()

```


## Prediction interval

```{r}
dd$y.lower = predict(lm1, 
                        newdata = dd, 
                        interval = 'prediction',
                        level = 0.95)[,'lwr']

dd$y.upper = predict(lm1, 
                        newdata = dd, 
                        interval = 'prediction',
                        level = 0.95)[,'upr']

dd %>% 
  select(team, score, opp.score, avg.score.prev, 
         yhat, yhat.lower, yhat.upper, 
         y.lower, y.upper) %>%
  head()
```



## Multiple linear regression

First let's prep the data. 

```{r}
## Days rest
dd = dd %>%
  arrange(date) %>%
  group_by(team, season) %>%
  mutate(days.rest = c(NA, diff(date))) 

head(dd)
tail(dd)
dd %>% filter(team=='PHI')
table(dd$days.rest)
```

Let's treat NA (first game of the season), as 4 or more.

```{r}
dd = dd %>% 
  mutate(days.rest = ifelse(is.na(days.rest), 4, days.rest))
head(dd)
```

Create rest differential `rest.diff` by grouping by `gid` and finding the difference in `days.rest` between the home and away team. 



```{r}
dd$days.rest = gsub('4 or more', 4, dd$days.rest)
dd$days.rest = as.numeric(dd$days.rest)

dd = dd %>%
  group_by(gid) %>%
  mutate(rest.diff = ifelse(ha=='home', diff(days.rest), -diff(days.rest))) %>%
  ungroup()

head(dd)
tail(dd)
```

Let's see how many games have each value of `days.rest` and `rest.diff`. 

```{r}
table(dd$days.rest)
table(dd$rest.diff)
```

Let's group higher values into a 4 or more category. We don't mind this being categorical because it's not clear that there is a linear relationship between days.rest and score. We'll do the same for rest.diff.


```{r}
dd = dd %>%
  mutate(days.rest = ifelse(days.rest >= 4 | is.na(days.rest), 
                            '4 or more',
                            days.rest), 
         rest.diff = case_when(rest.diff >=  3 ~  '3 or more', 
                               rest.diff <= -3 ~ '-3 or fewer', 
                               TRUE ~ as.character(rest.diff))) 

## check
head(dd,2)
tail(dd,2)
table(dd$days.rest)
table(dd$rest.diff)
```

Let's also add distance traveled before this game.

```{r} 
## Distance between every pair of cities. 
dm = read.csv('data/distance.matrix.nba.csv')
colnames(dm)[1] = 'prev.loc'
head(dm)

dm = dm %>% 
  pivot_longer(cols = - prev.loc, 
               names_to = 'loc', 
               values_to = 'miles')
head(dm)
```

Let's add these distances to our data frame. We need the location of the current game, as well as the location of the previous game `prev.loc`. Once we have `loc` and `prev.loc`, we can join the distances to this data frame. We can group by game and compute `miles.diff` like we did `rest.diff` above. 

```{r}
dd = dd %>% 
  group_by(team, season) %>%
  mutate(loc = ifelse(ha=='home', team, opp),
         prev.loc = lag(loc), 
         prev.loc = ifelse(is.na(prev.loc), team, prev.loc)) %>%
  left_join(dm, by=c('loc', 'prev.loc')) %>%
  group_by(gid) %>%
  mutate(miles.diff = ifelse(ha=='home', diff(miles), -diff(miles)))
  
## check
head(dd)
tail(dd)
dd %>% filter(team=='PHI')
```

Let's see if there is a relationship between `miles.diff` and `score`. 

```{r}
g = ggplot(dd, 
       aes(x = miles.diff, 
           y = score))+
  geom_point(alpha=0.05, 
             color=pubdarkgray)+
  geom_smooth(method='lm', 
              color=pubred)+
  labs(title='Relationship between miles.diff and score', 
       x='Miles Differential', 
       y='Score')

g %>% 
  pub(type='scatter')
```
Maybe a slightly negative relationship, but we might not expect a significant coefficient when we include this in a multiple regression model. 


## Modeling

```{r}
dm = dd %>% 
  filter(season == 2022)
lm1 = lm(score ~ ha                         , data=dm); summary(lm1)
lm2 = lm(score ~ ha + miles.diff            , data=dm); summary(lm2)  
lm3 = lm(score ~ ha + rest.diff             , data=dm); summary(lm3)
lm4 = lm(score ~ ha + rest.diff + team      , data=dm); summary(lm4)
lm5 = lm(score ~ ha + rest.diff + team + opp, data=dm); summary(lm5)
lm6 = lm(score ~ ha + rest.diff + team + opp + avg.score.prev, data=dm); summary(lm6)
```

Including `miles.diff` lowered Adj R^2, and was not significant, so we removed it. The `avg.score.prev` predictor was removed automatically by the `lm` function because of perfect collinearity. Other predictors increased Adj R^2, were significant, and had the expected signs, so we kept them in. The coefficient for -3 or fewer seems high but there were very few observations in that category. We could group that with -2 maybe. Other coefficients seem pretty reasonable.

Let's -2 or fewer instead of -3 or fewer, use 2 or more instead of 3 or more, and set the reference level to "0". Let's also create a column for `rest.diff` that is numeric for comparison. 

```{r}

dm = dm %>%
  mutate(rest.diff.num = gsub(' or.+', '', rest.diff), 
         rest.diff.num = as.numeric(rest.diff.num), 
         rest.diff = case_when(rest.diff %in% c('-2', '-3 or fewer') ~ '-2 or fewer', 
                               rest.diff %in% c('2', '3 or more') ~ '2 or more', 
                               TRUE ~ as.character(rest.diff)), 
         rest.diff = factor(rest.diff, 
                            levels = c('-2 or fewer', '-1', '0', '1', '2 or more')), 
         rest.diff = relevel(rest.diff, '0'))
table(dm$rest.diff.num)
table(dm$rest.diff)

lm7 = lm(score ~ ha + rest.diff     + team + opp, data=dm); summary(lm7)
lm8 = lm(score ~ ha + rest.diff.num + team + opp, data=dm); summary(lm8)
```

